var documenterSearchIndex = {"docs":
[{"location":"man/abstractblockarrayinterface/#The-block-axis-interface","page":"The block axis interface","title":"The block axis interface","text":"","category":"section"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"A block array's block structure is dictated by its axes. These are typically BlockedOneTos, but may also be standard and non-blocked AbstractUnitRanges (which are assumed to correspond to a single block), or other type that implements the block axis interface.","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"Methods to implement Brief description\nblockaxes(A) A one-tuple returning a range of blocks specifying the block structure\ngetindex(A, K::Block{1}) return a unit range of indices in the specified block\nblocklasts(A) Returns the last index of each block\nfindblock(A, k) return the block that contains the kth entry of A","category":"page"},{"location":"man/abstractblockarrayinterface/#The-AbstractBlockArray-interface","page":"The block axis interface","title":"The AbstractBlockArray interface","text":"","category":"section"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"An arrays block structure is inferred from an axes, and therefore every array is in some sense already a block array:","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"julia> A = randn(5,5)\n5×5 Matrix{Float64}:\n  0.452801   -0.416508   1.17406    1.52575     3.1574  \n  0.413142   -1.34722   -1.28597    0.637721    0.30655 \n  0.34907    -0.887615   0.284972  -0.0212884  -0.225832\n  0.466102   -1.10425    1.49226    0.968436   -2.13637 \n -0.0971956  -1.7664    -0.592629  -1.48947     1.53418 \n\njulia> A[Block(1,1)]\n5×5 Matrix{Float64}:\n  0.452801   -0.416508   1.17406    1.52575     3.1574  \n  0.413142   -1.34722   -1.28597    0.637721    0.30655 \n  0.34907    -0.887615   0.284972  -0.0212884  -0.225832\n  0.466102   -1.10425    1.49226    0.968436   -2.13637 \n -0.0971956  -1.7664    -0.592629  -1.48947     1.53418 ","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"It is possible to override additional functions to improve speed, however.","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"Methods to implement Brief description\nOptional methods \nBlockArrays.viewblock(A, i::Block) Specialised non-allocating X[Block(i...)], blocked indexing","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"For a more thorough description of the methods see the public interface documentation.","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"With the methods above implemented the following are automatically provided for arrays that are subtypes of AbstractBlockArray:","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"A pretty printing show function that uses unicode lines to split up the blocks:","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"julia> A = BlockArray(rand(4, 5), [1,3], [2,3])\n2×2-blocked 4×5 BlockMatrix{Float64}:\n0.61179   0.965631  │  0.696476   0.392796  0.712462\n--------------------┼-------------------------------\n0.620099  0.364706  │  0.0311643  0.27895   0.73477\n0.215712  0.923602  │  0.279944   0.994497  0.383706\n0.569955  0.754047  │  0.0190392  0.548297  0.687052","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"A bounds index checking function for indexing with blocks:","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"julia> blockcheckbounds(A, 5, 3)\nERROR: BlockBoundsError: attempt to access 2×2-blocked 4×5 BlockMatrix{Float64, Matrix{Float64}} at block index [5,3]","category":"page"},{"location":"man/abstractblockarrayinterface/","page":"The block axis interface","title":"The block axis interface","text":"Happy users who know how to use your new block array :)","category":"page"},{"location":"man/blockarrays/#BlockArrays","page":"BlockArrays","title":"BlockArrays","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"DocTestSetup = quote\n    using BlockArrays, SparseArrays\nend","category":"page"},{"location":"man/blockarrays/#Creating-BlockArrays-from-an-array","page":"BlockArrays","title":"Creating BlockArrays from an array","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"An AbstractArray can be repacked into a BlockArray with BlockArray(array, block_sizes...).  The block sizes are each an AbstractVector{Int} which determines the size of the blocks in that dimension (so the sum of block_sizes in every dimension must match the size of array in that dimension).","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> BlockArray(Array(reshape(1:16, 4, 4)), [2,2], [1,1,2])\n2×3-blocked 4×4 BlockMatrix{Int64}:\n 1  │  5  │   9  13\n 2  │  6  │  10  14\n ───┼─────┼────────\n 3  │  7  │  11  15\n 4  │  8  │  12  16\n\njulia> S = spzeros(4,5); S[1,2] = S[4,3] = 1;\n\njulia> block_array_sparse = BlockArray(S, [1,3], [2,3])\n2×2-blocked 4×5 BlockMatrix{Float64, Matrix{SparseMatrixCSC{Float64, Int64}}, Tuple{BlockedOneTo{Int64, Vector{Int64}}, BlockedOneTo{Int64, Vector{Int64}}}}:\n  ⋅   1.0  │   ⋅    ⋅    ⋅ \n ──────────┼───────────────\n  ⋅    ⋅   │   ⋅    ⋅    ⋅ \n  ⋅    ⋅   │   ⋅    ⋅    ⋅ \n  ⋅    ⋅   │  1.0   ⋅    ⋅ ","category":"page"},{"location":"man/blockarrays/#Creating-uninitialized-BlockArrays","page":"BlockArrays","title":"Creating uninitialized BlockArrays","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"A block array can be created with uninitialized values (but initialized blocks) using the BlockArray{T}(undef, block_sizes) function. The block_sizes are each an AbstractVector{Int} which determines the size of the blocks in that dimension. We here create a block matrix of Float32s:","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> BlockArray{Float32}(undef, [1,2,1], [1,1,1])\n3×3-blocked 4×3 BlockMatrix{Float32}:\n -2.15145e-35  │   1.4013e-45   │  -1.77199e-35\n ──────────────┼────────────────┼──────────────\n  1.4013e-45   │  -1.77199e-35  │  -1.72473e-34\n  1.4013e-45   │   4.57202e-41  │   4.57202e-41\n ──────────────┼────────────────┼──────────────\n  0.0          │  -1.36568e-33  │  -1.72473e-34","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"We can also any other user defined array type that supports similar.","category":"page"},{"location":"man/blockarrays/#Creating-BlockArrays-with-uninitialized-blocks.","page":"BlockArrays","title":"Creating BlockArrays with uninitialized blocks.","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"A BlockArray can be created with the blocks left uninitialized using the BlockArray(undef_blocks[, block_type], block_sizes...) function.  We here create a [1,2]×[3,2] block matrix of Float32s:","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> BlockArray{Float32}(undef_blocks, [1,2], [3,2])\n2×2-blocked 3×5 BlockMatrix{Float32}:\n #undef  #undef  #undef  │  #undef  #undef\n ────────────────────────┼────────────────\n #undef  #undef  #undef  │  #undef  #undef\n #undef  #undef  #undef  │  #undef  #undef","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"The block_type should be an array type.  It specifies the internal block type, which defaults to an Array of the according dimension.  We can also use a SparseVector or any other user defined array type:","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> BlockArray(undef_blocks, SparseVector{Float64, Int}, [1,2])\n2-blocked 3-element BlockVector{Float64, Vector{SparseVector{Float64, Int64}}, Tuple{BlockedOneTo{Int64, Vector{Int64}}}}:\n #undef\n ──────\n #undef\n #undef","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"warning: Warning\nNote that accessing an undefined block will throw an \"access to undefined reference\"-error!  If you create an array with undefined blocks, you have to initialize it block-wise); whole-array functions like fill! will not work:julia> fill!(BlockArray{Float32}(undef_blocks, [1,2], [3,2]), 0)\nERROR: UndefRefError: access to undefined reference","category":"page"},{"location":"man/blockarrays/#setting_and_getting","page":"BlockArrays","title":"Setting and getting blocks and values","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"A block can be set by  block_array[Block(i...)] = v. The indexing may equivalently be carried out as block_array[Block.(i)...].","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> block_array = BlockArray{Float64}(undef_blocks, [1,2], [2,2])\n2×2-blocked 3×4 BlockMatrix{Float64}:\n #undef  #undef  │  #undef  #undef\n ────────────────┼────────────────\n #undef  #undef  │  #undef  #undef\n #undef  #undef  │  #undef  #undef\n\njulia> block_array[Block(2,1)] = reshape([1:4;], 2, 2);\n\njulia> block_array[Block(1),Block(1)] = [1 2];\n\njulia> block_array\n2×2-blocked 3×4 BlockMatrix{Float64}:\n 1.0  2.0  │  #undef  #undef\n ──────────┼────────────────\n 1.0  3.0  │  #undef  #undef\n 2.0  4.0  │  #undef  #undef","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"Note that this will \"take ownership\" of the passed in array, that is, no copy is made.","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"A block can be retrieved with view(block_array, Block(i...)), or if a copy is desired, block_array[Block(i...)]:","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> view(block_array, Block(1, 1))\n1×2 Matrix{Float64}:\n 1.0  2.0\n\njulia> block_array[Block(1, 1)] # makes a copy\n1×2 Matrix{Float64}:\n 1.0  2.0\n\njulia> block_array[Block(1), Block(1)]  # equivalent to above\n1×2 Matrix{Float64}:\n 1.0  2.0","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"For setting and getting a single scalar element, the usual setindex! and getindex are available.","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> block_array[1, 2]\n2.0","category":"page"},{"location":"man/blockarrays/#Views-of-blocks","page":"BlockArrays","title":"Views of blocks","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"To view and modify blocks of BlockArray use the view syntax.","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> A = BlockArray(ones(6), 1:3);\n\njulia> view(A, Block(2))\n2-element Vector{Float64}:\n 1.0\n 1.0\n\njulia> view(A, Block(2)) .= [3,4]; A[Block(2)]\n2-element Vector{Float64}:\n 3.0\n 4.0\n\njulia> view(A, Block.(1:2))\n3-element view(::BlockVector{Float64, Vector{Vector{Float64}}, Tuple{BlockedOneTo{Int64, ArrayLayouts.RangeCumsum{Int64, UnitRange{Int64}}}}}, BlockSlice(BlockRange(1:2),1:1:3)) with eltype Float64 with indices BlockedOneTo([1, 3]):\n 1.0\n 3.0\n 4.0","category":"page"},{"location":"man/blockarrays/#Converting-between-BlockArray-and-normal-arrays","page":"BlockArrays","title":"Converting between BlockArray and normal arrays","text":"","category":"section"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"An array can be repacked into a BlockArray with BlockArray(array, block_sizes...):","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> S = spzeros(4,5); S[1,2] = S[4,3] = 1;\n\njulia> block_array_sparse = BlockArray(S, [1,3], [2,3])\n2×2-blocked 4×5 BlockMatrix{Float64, Matrix{SparseMatrixCSC{Float64, Int64}}, Tuple{BlockedOneTo{Int64, Vector{Int64}}, BlockedOneTo{Int64, Vector{Int64}}}}:\n  ⋅   1.0  │   ⋅    ⋅    ⋅ \n ──────────┼───────────────\n  ⋅    ⋅   │   ⋅    ⋅    ⋅ \n  ⋅    ⋅   │   ⋅    ⋅    ⋅ \n  ⋅    ⋅   │  1.0   ⋅    ⋅ ","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"To get back the underlying sparse array, use sparse:","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> sparse(block_array_sparse)\n4×5 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅ ","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"To get a dense array, use Array:","category":"page"},{"location":"man/blockarrays/","page":"BlockArrays","title":"BlockArrays","text":"julia> Array(block_array_sparse)\n4×5 Matrix{Float64}:\n 0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0","category":"page"},{"location":"man/blockedarrays/#BlockedArrays","page":"BlockedArrays","title":"BlockedArrays","text":"","category":"section"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"DocTestSetup = quote\n    using BlockArrays\n    using Random\n    Random.seed!(1234)\nend","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"A BlockedArray is similar to a BlockArray except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand, converting a BlockedArray to the \"full\" underlying array is instead instant since it can just return the wrapped array.","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"When iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a BlockedArray to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using Matrix.","category":"page"},{"location":"man/blockedarrays/#Creating-BlockedArrays","page":"BlockedArrays","title":"Creating BlockedArrays","text":"","category":"section"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"Creating a BlockedArray works in the same way as a BlockArray.","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"julia> pseudo = BlockedArray(reshape([1:9;], 3, 3), [1,2], [2,1])\n2×2-blocked 3×3 BlockedMatrix{Int64}:\n 1  4  │  7\n ──────┼───\n 2  5  │  8\n 3  6  │  9","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"This \"takes ownership\" of the passed in array so no copy of the array is made.","category":"page"},{"location":"man/blockedarrays/#Creating-initialized-BlockArrays","page":"BlockedArrays","title":"Creating initialized BlockArrays","text":"","category":"section"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"A block array can be created with uninitialized entries using the BlockArray{T}(undef, block_sizes...) function. The block_sizes are each an AbstractVector{Int} which determines the size of the blocks in that dimension. We here create a [1,2]×[3,2] block matrix of Float32s:","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"julia> BlockedArray{Float32}(undef, [1,2], [3,2])\n2×2-blocked 3×5 BlockedMatrix{Float32}:\n 1.02295e-43  0.0          1.09301e-43  │  0.0          1.17709e-43\n ───────────────────────────────────────┼──────────────────────────\n 0.0          1.06499e-43  0.0          │  1.14906e-43  0.0\n 1.05097e-43  0.0          1.13505e-43  │  0.0          1.1911e-43","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"We can also any other user defined array type that supports similar.","category":"page"},{"location":"man/blockedarrays/#Setting-and-getting-blocks-and-values","page":"BlockedArrays","title":"Setting and getting blocks and values","text":"","category":"section"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"Setting and getting blocks uses the same API as BlockArrays. The difference here is that setting a block will update the block in place and getting a block will extract a copy of the block and return it. Note to update a passed in array without allocating one can use views:","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"julia> A = zeros(2,2)\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\njulia> copyto!(A, view(pseudo, Block(2, 1)));\n\njulia> A\n2×2 Matrix{Float64}:\n 2.0  5.0\n 3.0  6.0","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"It is sometimes convenient to access an index in a certain block. We could of course write this as A[Block(I,J)][i,j] but the problem is that A[Block(I,J)] allocates its output so this type of indexing will be inefficient. Instead, it is possible to use the A[BlockIndex((I,J), (i,j))] indexing. Using the same block matrix A as above:","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"julia> pseudo[BlockIndex((2,1), (2,2))]\n6","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"The underlying array is accessed with Array just like for BlockArray.","category":"page"},{"location":"man/blockedarrays/#Views-of-blocks","page":"BlockedArrays","title":"Views of blocks","text":"","category":"section"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"We can also view and modify views of blocks of BlockedArray using the view syntax:","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"julia> A = BlockedArray(ones(6), 1:3);\n\njulia> view(A, Block(2))\n2-element view(::Vector{Float64}, 2:3) with eltype Float64:\n 1.0\n 1.0\n\njulia> view(A, Block(2)) .= [3,4]; A[Block(2)]\n2-element Vector{Float64}:\n 3.0\n 4.0","category":"page"},{"location":"man/blockedarrays/","page":"BlockedArrays","title":"BlockedArrays","text":"Note that, in memory, each block is in a BLAS-Level 3 compatible format, so that algebra with blocks is highly efficient.","category":"page"},{"location":"lib/internals/","page":"Internal Documentation","title":"Internal Documentation","text":"CurrentModule = BlockArrays","category":"page"},{"location":"lib/internals/#Internal-Documentation","page":"Internal Documentation","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals/#Contents","page":"Internal Documentation","title":"Contents","text":"","category":"section"},{"location":"lib/internals/","page":"Internal Documentation","title":"Internal Documentation","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Index","page":"Internal Documentation","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internal Documentation","title":"Internal Documentation","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Internals","page":"Internal Documentation","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internal Documentation","title":"Internal Documentation","text":"blockcolsupport\nblockrowsupport\nblockedrange\nBlockedOneTo\nBlockedUnitRange\nBlockRange\nBlockIndexRange\nBlockSlice\nunblock\nSubBlockIterator\nblockcheckbounds_indices\nblockcheckindex","category":"page"},{"location":"lib/internals/#BlockArrays.blockcolsupport","page":"Internal Documentation","title":"BlockArrays.blockcolsupport","text":"blockcolsupport(A, j)\n\nReturn an iterator containing the possible non-zero blocks in the j-th block-column of A.\n\nExamples\n\njulia> B = BlockArray(collect(reshape(1:9, 3, 3)), [1,2], [1,1,1])\n2×3-blocked 3×3 BlockMatrix{Int64}:\n 1  │  4  │  7\n ───┼─────┼───\n 2  │  5  │  8\n 3  │  6  │  9\n\njulia> BlockArrays.blockcolsupport(B, 2) |> collect\n2-element Vector{Block{1, Int64}}:\n Block(1)\n Block(2)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#BlockArrays.blockrowsupport","page":"Internal Documentation","title":"BlockArrays.blockrowsupport","text":"blockrowsupport(A, k)\n\nReturn an iterator containing the possible non-zero blocks in the k-th block-row of A.\n\nExamples\n\njulia> B = BlockArray(collect(reshape(1:9, 3, 3)), [1,2], [1,1,1])\n2×3-blocked 3×3 BlockMatrix{Int64}:\n 1  │  4  │  7\n ───┼─────┼───\n 2  │  5  │  8\n 3  │  6  │  9\n\njulia> BlockArrays.blockrowsupport(B, 2) |> collect\n3-element Vector{Block{1, Int64}}:\n Block(1)\n Block(2)\n Block(3)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#BlockArrays.blockedrange","page":"Internal Documentation","title":"BlockArrays.blockedrange","text":"blockedrange(blocklengths::Union{Tuple, AbstractVector})\nblockedrange(first::Integer, blocklengths::Union{Tuple, AbstractVector})\n\nReturn a blocked AbstractUnitRange{<:Integer} with the block sizes being blocklengths. If first is provided, this is used as the first value of the range. Otherwise, if only the block lengths are provided, first is assumed to be 1.\n\nExamples\n\njulia> blockedrange([1,2])\n2-blocked 3-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n ─\n 2\n 3\n\njulia> blockedrange(2, (1,2))\n2-blocked 3-element BlockedUnitRange{Int64, Tuple{Int64, Int64}}:\n 2\n ─\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#BlockArrays.BlockedOneTo","page":"Internal Documentation","title":"BlockArrays.BlockedOneTo","text":"BlockedOneTo{T, <:Union{AbstractVector{T}, NTuple{<:Any,T}}} where {T}\n\nDefine an AbstractUnitRange{T} that has been divided into blocks, which is used to represent axes of block arrays. This parallels Base.OneTo in that the first value is guaranteed to be 1.\n\nConstruction is typically via blockedrange which converts a vector of block lengths to a BlockedUnitRange.\n\nExamples\n\njulia> blockedrange([2,2,3]) # block lengths\n3-blocked 7-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n 2\n ─\n 3\n 4\n ─\n 5\n 6\n 7\n\nSee also BlockedUnitRange.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#BlockArrays.BlockedUnitRange","page":"Internal Documentation","title":"BlockArrays.BlockedUnitRange","text":"BlockedUnitRange\n\nis an AbstractUnitRange{<:Integer} that has been divided into blocks. Construction is typically via blockedrange which converts a vector of block lengths to a BlockedUnitRange.\n\nExamples\n\njulia> blockedrange(2, [2,2,3]) # first value and block lengths\n3-blocked 7-element BlockedUnitRange{Int64, Vector{Int64}}:\n 2\n 3\n ─\n 4\n 5\n ─\n 6\n 7\n 8\n\nSee also BlockedOneTo.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#BlockArrays.BlockRange","page":"Internal Documentation","title":"BlockArrays.BlockRange","text":"BlockRange(axes::Tuple{AbstractUnitRange{Int}})\nBlockRange(sizes::Vararg{Integer})\n\nRepresent a Cartesian range of blocks.\n\nThe relationship between Block and BlockRange mimics the relationship between CartesianIndex and CartesianIndices.\n\nExamples\n\njulia> BlockRange(2:3, 3:4) |> collect\n2×2 Matrix{Block{2, Int64}}:\n Block(2, 3)  Block(2, 4)\n Block(3, 3)  Block(3, 4)\n\njulia> BlockRange(2, 2) |> collect # number of elements, starting at 1\n2×2 Matrix{Block{2, Int64}}:\n Block(1, 1)  Block(1, 2)\n Block(2, 1)  Block(2, 2)\n\njulia> Block(1):Block(2)\nBlockRange(1:2)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#BlockArrays.BlockIndexRange","page":"Internal Documentation","title":"BlockArrays.BlockIndexRange","text":"BlockIndexRange(block, startind:stopind)\n\nrepresents a cartesian range inside a block.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#BlockArrays.BlockSlice","page":"Internal Documentation","title":"BlockArrays.BlockSlice","text":"BlockSlice(indices)\n\nRepresent an AbstractUnitRange of indices that attaches a block.\n\nUpon calling to_indices(), Blocks are converted to BlockSlice objects to represent the indices over which the Block spans.\n\nThis mimics the relationship between Colon and Base.Slice.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#BlockArrays.unblock","page":"Internal Documentation","title":"BlockArrays.unblock","text":"unblock(block_sizes, inds, I)\n\nReturns the indices associated with a block as a BlockSlice.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#BlockArrays.SubBlockIterator","page":"Internal Documentation","title":"BlockArrays.SubBlockIterator","text":"SubBlockIterator(subblock_lasts::Vector{Int}, block_lasts::Vector{Int})\nSubBlockIterator(A::AbstractArray, bs::NTuple{N,AbstractUnitRange{Int}} where N, dim::Integer)\n\nReturn an iterator over the BlockIndexRanges of the blocks specified by subblock_lasts.  The Block index part of BlockIndexRange is determined by subblock_lasts.  That is to say, the Block index first specifies one of the block represented by subblock_lasts and then the inner-block index range specifies the region within the block.  Each such block corresponds to a block specified by blocklasts.\n\nNote that the invariance subblock_lasts ⊂ block_lasts must hold and must be ensured by the caller.\n\nExamples\n\njulia> using BlockArrays\n\njulia> import BlockArrays: SubBlockIterator\n\njulia> A = BlockArray(1:6, 1:3);\n\njulia> subblock_lasts = blocklasts(axes(A, 1))\n3-element ArrayLayouts.RangeCumsum{Int64, UnitRange{Int64}}:\n 1\n 3\n 6\n\njulia> block_lasts = [1, 3, 4, 6];\n\njulia> itr = SubBlockIterator(subblock_lasts, block_lasts)\nSubBlockIterator([1, 3, 6], [1, 3, 4, 6])\n\njulia> collect(itr)\n4-element Vector{BlockArrays.BlockIndexRange{1, Tuple{UnitRange{Int64}}, Tuple{Int64}, Int64}}:\n Block(1)[1:1]\n Block(2)[1:2]\n Block(3)[1:1]\n Block(3)[2:3]\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#BlockArrays.blockcheckbounds_indices","page":"Internal Documentation","title":"BlockArrays.blockcheckbounds_indices","text":"blockcheckbounds_indices(Bool, IA::Tuple{Vararg{BlockRange{1}}}, I::Tuple{Vararg{Integer}})\n\nReturn true if the \"requested\" indices in the tuple Block.(I) fall within the bounds of the \"permitted\" indices specified by the tuple IA. This function recursively consumes elements of these tuples in a 1-for-1 fashion.\n\nThe actual bounds-checking is performed by blockcheckindex.\n\nExamples\n\njulia> B = BlockArray(zeros(6,6), 1:3, 1:3);\n\njulia> blockaxes(B)\n(BlockRange(Base.OneTo(3)), BlockRange(Base.OneTo(3)))\n\njulia> BlockArrays.blockcheckbounds_indices(Bool, blockaxes(B), (1,2))\ntrue\n\njulia> BlockArrays.blockcheckbounds_indices(Bool, blockaxes(B), (4,1))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#BlockArrays.blockcheckindex","page":"Internal Documentation","title":"BlockArrays.blockcheckindex","text":"blockcheckindex(Bool, inds::BlockRange{1}, index::Integer)\n\nReturn true if Block(index) is within the bounds of inds.\n\nExamples\n\njulia> BlockArrays.blockcheckindex(Bool, BlockRange(1:2), 1)\ntrue\n\njulia> BlockArrays.blockcheckindex(Bool, BlockRange(1:2), 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"CurrentModule = BlockArrays","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"Documentation for BlockArrays.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"See Internal Documentation for internal package docs covering all submodules.","category":"page"},{"location":"lib/public/#Contents","page":"Public Documentation","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Index","page":"Public Documentation","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#AbstractBlockArray-interface","page":"Public Documentation","title":"AbstractBlockArray interface","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"This sections defines the functions a subtype of AbstractBlockArray should define to be a part of the AbstractBlockArray interface. An AbstractBlockArray{T, N} is a subtype of AbstractArray{T,N} and should therefore also fulfill the AbstractArray interface.","category":"page"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"AbstractBlockArray\nBlockBoundsError\nBlock\nBlockIndex\nblockaxes\nblockisequal\nblocksize\nblockfirsts\nblocklasts\nblocklengths\nblocksizes\nblocks\neachblock\nblockcheckbounds","category":"page"},{"location":"lib/public/#BlockArrays.AbstractBlockArray","page":"Public Documentation","title":"BlockArrays.AbstractBlockArray","text":"abstract AbstractBlockArray{T, N} <: AbstractArray{T, N}\n\nThe abstract type that represents a blocked array. Types that implement the AbstractBlockArray interface should subtype from this type.\n\n** Typealiases **\n\nAbstractBlockMatrix{T} -> AbstractBlockArray{T, 2}\nAbstractBlockVector{T} -> AbstractBlockArray{T, 1}\nAbstractBlockVecOrMat{T} -> Union{AbstractBlockMatrix{T}, AbstractBlockVector{T}}\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.BlockBoundsError","page":"Public Documentation","title":"BlockArrays.BlockBoundsError","text":"BlockBoundsError([A], [inds...])\n\nThrown when a block indexing operation into a block array, A, tried to access an out-of-bounds block, inds.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.Block","page":"Public Documentation","title":"BlockArrays.Block","text":"Block(inds...)\n\nA Block is simply a wrapper around a set of indices or enums so that it can be used to dispatch on. By indexing a AbstractBlockArray with a Block the a block at that block index will be returned instead of a single element.\n\njulia> A = BlockArray(ones(2,3), [1, 1], [2, 1])\n2×2-blocked 2×3 BlockMatrix{Float64}:\n 1.0  1.0  │  1.0\n ──────────┼─────\n 1.0  1.0  │  1.0\n\njulia> A[Block(1, 1)]\n1×2 Matrix{Float64}:\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.BlockIndex","page":"Public Documentation","title":"BlockArrays.BlockIndex","text":"BlockIndex{N}\n\nA BlockIndex is an index which stores a global index in two parts: the block and the offset index into the block.\n\nIt can be used to index into BlockArrays in the following manner:\n\njulia> arr = Array(reshape(1:25, (5,5)));\n\njulia> a = BlockedArray(arr, [3,2], [1,4])\n2×2-blocked 5×5 BlockedMatrix{Int64}:\n 1  │   6  11  16  21\n 2  │   7  12  17  22\n 3  │   8  13  18  23\n ───┼────────────────\n 4  │   9  14  19  24\n 5  │  10  15  20  25\n\njulia> a[BlockIndex((1,2), (1,2))]\n11\n\njulia> a[BlockIndex((2,2), (2,3))]\n20\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.blockaxes","page":"Public Documentation","title":"BlockArrays.blockaxes","text":"blockaxes(A::AbstractArray)\n\nReturn the tuple of valid block indices for array A.\n\nExamples\n\njulia> A = BlockArray([1,2,3],[2,1])\n2-blocked 3-element BlockVector{Int64}:\n 1\n 2\n ─\n 3\n\njulia> blockaxes(A)\n(BlockRange(Base.OneTo(2)),)\n\njulia> B = BlockArray(zeros(3,4), [1,2], [1,2,1])\n2×3-blocked 3×4 BlockMatrix{Float64}:\n 0.0  │  0.0  0.0  │  0.0\n ─────┼────────────┼─────\n 0.0  │  0.0  0.0  │  0.0\n 0.0  │  0.0  0.0  │  0.0\n\njulia> blockaxes(B)\n(BlockRange(Base.OneTo(2)), BlockRange(Base.OneTo(3)))\n\n\n\n\n\nblockaxes(A::AbstractArray, d::Int)\n\nReturn the valid range of block indices for array A along dimension d.\n\nExamples\n\njulia> A = BlockArray([1,2,3], [2,1])\n2-blocked 3-element BlockVector{Int64}:\n 1\n 2\n ─\n 3\n\njulia> blockaxes(A,1)\nBlockRange(Base.OneTo(2))\n\njulia> blockaxes(A,1) |> collect\n2-element Vector{Block{1, Int64}}:\n Block(1)\n Block(2)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockisequal","page":"Public Documentation","title":"BlockArrays.blockisequal","text":"blockisequal(a::AbstractUnitRange{<:Integer}, b::AbstractUnitRange{<:Integer})\n\nCheck if a and b have the same block structure.\n\nExamples\n\njulia> b1 = blockedrange([1,2])\n2-blocked 3-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n ─\n 2\n 3\n\njulia> b2 = blockedrange([1,1,1])\n3-blocked 3-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n ─\n 2\n ─\n 3\n\njulia> blockisequal(b1, b1)\ntrue\n\njulia> blockisequal(b1, b2)\nfalse\n\n\n\n\n\nblockisequal(a::Tuple, b::Tuple)\n\nReturn if the tuples satisfy blockisequal elementwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blocksize","page":"Public Documentation","title":"BlockArrays.blocksize","text":"blocksize(A::AbstractArray)\nblocksize(A::AbstractArray, i::Int)\n\nReturn the tuple of the number of blocks along each dimension. See also size and blocksizes.\n\nExamples\n\njulia> A = BlockArray(ones(3,3),[2,1],[1,1,1])\n2×3-blocked 3×3 BlockMatrix{Float64}:\n 1.0  │  1.0  │  1.0\n 1.0  │  1.0  │  1.0\n ─────┼───────┼─────\n 1.0  │  1.0  │  1.0\n\njulia> blocksize(A)\n(2, 3)\n\njulia> blocksize(A,2)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockfirsts","page":"Public Documentation","title":"BlockArrays.blockfirsts","text":"blockfirsts(a::AbstractUnitRange{<:Integer})\n\nReturn the first index of each block of a.\n\nExamples\n\njulia> b = blockedrange([1,2,3])\n3-blocked 6-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n ─\n 2\n 3\n ─\n 4\n 5\n 6\n\njulia> blockfirsts(b)\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blocklasts","page":"Public Documentation","title":"BlockArrays.blocklasts","text":"blocklasts(a::AbstractUnitRange{<:Integer})\n\nReturn the last index of each block of a.\n\nExamples\n\njulia> b = blockedrange([1,2,3])\n3-blocked 6-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n ─\n 2\n 3\n ─\n 4\n 5\n 6\n\njulia> blocklasts(b)\n3-element Vector{Int64}:\n 1\n 3\n 6\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blocklengths","page":"Public Documentation","title":"BlockArrays.blocklengths","text":"blocklengths(a::AbstractUnitRange{<:Integer})\n\nReturn the length of each block of a.\n\nExamples\n\njulia> b = blockedrange([1,2,3])\n3-blocked 6-element BlockedOneTo{Int64, Vector{Int64}}:\n 1\n ─\n 2\n 3\n ─\n 4\n 5\n 6\n\njulia> blocklengths(b)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blocksizes","page":"Public Documentation","title":"BlockArrays.blocksizes","text":"blocksizes(A::AbstractArray)\nblocksizes(A::AbstractArray, d::Integer)\n\nReturn an iterator over the sizes of each block. See also size and blocksize.\n\nExamples\n\njulia> A = BlockArray(ones(3,3),[2,1],[1,1,1])\n2×3-blocked 3×3 BlockMatrix{Float64}:\n 1.0  │  1.0  │  1.0\n 1.0  │  1.0  │  1.0\n ─────┼───────┼─────\n 1.0  │  1.0  │  1.0\n\njulia> blocksizes(A)\n2×3 BlockArrays.BlockSizes{Tuple{Int64, Int64}, 2, BlockMatrix{Float64, Matrix{Matrix{Float64}}, Tuple{BlockedOneTo{Int64, Vector{Int64}}, BlockedOneTo{Int64, Vector{Int64}}}}}:\n (2, 1)  (2, 1)  (2, 1)\n (1, 1)  (1, 1)  (1, 1)\n\njulia> blocksizes(A)[1,2]\n(2, 1)\n\njulia> blocksizes(A,2)\n3-element Vector{Int64}:\n 1\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blocks","page":"Public Documentation","title":"BlockArrays.blocks","text":"blocks(a::AbstractArray{T,N}) :: AbstractArray{<:AbstractArray{T,N},N}\n\nReturn the array-of-arrays view to a such that\n\nblocks(a)[i₁, i₂, ..., iₙ] == a[Block(i₁), Block(i₂), ..., Block(iₙ)]\n\nThis function does not copy the blocks and give a mutable viwe to the original array.  This is an \"inverse\" of mortar.\n\nExamples\n\njulia> bs1 = permutedims(reshape([\n               1ones(1, 3), 2ones(1, 2),\n               3ones(2, 3), 4ones(2, 2),\n           ], (2, 2)))\n2×2 Matrix{Matrix{Float64}}:\n [1.0 1.0 1.0]               [2.0 2.0]\n [3.0 3.0 3.0; 3.0 3.0 3.0]  [4.0 4.0; 4.0 4.0]\n\njulia> a = mortar(bs1)\n2×2-blocked 3×5 BlockMatrix{Float64}:\n 1.0  1.0  1.0  │  2.0  2.0\n ───────────────┼──────────\n 3.0  3.0  3.0  │  4.0  4.0\n 3.0  3.0  3.0  │  4.0  4.0\n\njulia> bs2 = blocks(a)\n2×2 Matrix{Matrix{Float64}}:\n [1.0 1.0 1.0]               [2.0 2.0]\n [3.0 3.0 3.0; 3.0 3.0 3.0]  [4.0 4.0; 4.0 4.0]\n\njulia> bs1 == bs2\ntrue\n\njulia> bs2[1, 1] .*= 100;\n\njulia> a  # in-place mutation is reflected to the block array\n2×2-blocked 3×5 BlockMatrix{Float64}:\n 100.0  100.0  100.0  │  2.0  2.0\n ─────────────────────┼──────────\n   3.0    3.0    3.0  │  4.0  4.0\n   3.0    3.0    3.0  │  4.0  4.0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.eachblock","page":"Public Documentation","title":"BlockArrays.eachblock","text":"eachblock(A::AbstractBlockArray)\n\nCreate a generator that iterates over each block of an AbstractBlockArray returning views.\n\njulia> v = Array(reshape(1:6, (2, 3)))\n2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia> A = BlockArray(v, [1,1], [2,1])\n2×2-blocked 2×3 BlockMatrix{Int64}:\n 1  3  │  5\n ──────┼───\n 2  4  │  6\n\njulia> sum.(eachblock(A))\n2×2 Matrix{Int64}:\n 4  5\n 6  6\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockcheckbounds","page":"Public Documentation","title":"BlockArrays.blockcheckbounds","text":"blockcheckbounds(A, inds...)\n\nThrow a BlockBoundsError if the specified block indexes are not in bounds for the given block array. Subtypes of AbstractBlockArray should specialize this method if they need to provide custom block bounds checking behaviors.\n\njulia> A = BlockArray(rand(2,3), [1,1], [2,1]);\n\njulia> blockcheckbounds(A, 3, 2)\nERROR: BlockBoundsError: attempt to access 2×2-blocked 2×3 BlockMatrix{Float64} at block index [3,2]\n[...]\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArray","page":"Public Documentation","title":"BlockArray","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"BlockArray\nBlockArray(::UndefBlocksInitializer, ::Type{R}, block_sizes::Vararg{AbstractVector{<:Integer}, N}) where {T, N, R<:AbstractArray{T,N}}\nBlockArray{T}(::UndefBlocksInitializer, block_sizes::Vararg{AbstractVector{<:Integer}, N}) where {T, N}\nBlockArray{T}(::UndefInitializer, block_sizes::Vararg{AbstractVector{<:Integer}, N}) where {T, N}\nundef_blocks\nUndefBlocksInitializer\nmortar\nblockappend!\nblockpush!\nblockpushfirst!\nblockpop!\nblockpopfirst!\nBase.append!\nBase.push!\nBase.pushfirst!\nBase.pop!\nBase.popfirst!","category":"page"},{"location":"lib/public/#BlockArrays.BlockArray","page":"Public Documentation","title":"BlockArrays.BlockArray","text":"BlockArray{T, N, R<:AbstractArray{<:AbstractArray{T,N},N}, BS<:Tuple{Vararg{AbstractUnitRange{<:Integer},N}}} <: AbstractBlockArray{T, N}\n\nA BlockArray is an array where each block is stored contiguously. This means that insertions and retrieval of blocks can be very fast and non allocating since no copying of data is needed.\n\nIn the type definition, R defines the array type that holds the blocks, for example Matrix{Matrix{Float64}}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.BlockArray-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{BlockArrays.UndefBlocksInitializer, Type{R}, Vararg{AbstractVector{<:Integer}, N}}} where {T, N, R<:AbstractArray{T, N}}","page":"Public Documentation","title":"BlockArrays.BlockArray","text":"BlockArray(::UndefBlocksInitializer, ::Type{R}, block_sizes::Vararg{AbstractVector{<:Integer}, N}) where {N,R<:AbstractArray{<:Any,N}}\n\nConstruct a N-dim BlockArray with uninitialized blocks from a block type R, with sizes defined by block_sizes. Each block must be allocated before being accessed.\n\nExamples\n\njulia> B = BlockArray(undef_blocks, Matrix{Float64}, [1,3], [2,2])\n2×2-blocked 4×4 BlockMatrix{Float64}:\n #undef  #undef  │  #undef  #undef\n ────────────────┼────────────────\n #undef  #undef  │  #undef  #undef\n #undef  #undef  │  #undef  #undef\n #undef  #undef  │  #undef  #undef\n\njulia> typeof(blocks(B))\nMatrix{Matrix{Float64}} (alias for Array{Array{Float64, 2}, 2})\n\njulia> using SparseArrays\n\njulia> B = BlockArray(undef_blocks, SparseMatrixCSC{Float64,Int}, [1,3], [2,2]);\n\njulia> typeof(blocks(B))\nMatrix{SparseMatrixCSC{Float64, Int64}} (alias for Array{SparseMatrixCSC{Float64, Int64}, 2})\n\nSee also undef_blocks, UndefBlocksInitializer\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BlockArrays.BlockArray-Union{Tuple{N}, Tuple{T}, Tuple{BlockArrays.UndefBlocksInitializer, Vararg{AbstractVector{<:Integer}, N}}} where {T, N}","page":"Public Documentation","title":"BlockArrays.BlockArray","text":"BlockArray{T}(::UndefBlocksInitializer, block_sizes::Vararg{AbstractVector{<:Integer}, N}) where {T,N}\n\nConstruct a N-dim BlockArray with uninitialized blocks of type Array{T,N}, with sizes defined by block_sizes. Each block must be allocated before being accessed.\n\nExamples\n\njulia> B = BlockArray{Float64}(undef_blocks, [1,2], [1,2])\n2×2-blocked 3×3 BlockMatrix{Float64}:\n #undef  │  #undef  #undef\n ────────┼────────────────\n #undef  │  #undef  #undef\n #undef  │  #undef  #undef\n\njulia> typeof(blocks(B))\nMatrix{Matrix{Float64}} (alias for Array{Array{Float64, 2}, 2})\n\njulia> B = BlockArray{Int8}(undef_blocks, [1,2])\n2-blocked 3-element BlockVector{Int8}:\n #undef\n ──────\n #undef\n #undef\n\njulia> typeof(blocks(B))\nVector{Vector{Int8}} (alias for Array{Array{Int8, 1}, 1})\n\njulia> B[Block(1)] .= 2 # errors, as the block is not allocated yet\nERROR: UndefRefError: access to undefined reference\n[...]\n\njulia> B[Block(1)] = [1]; # assign an array to the block\n\njulia> B[Block(2)] = [2,3];\n\njulia> B\n2-blocked 3-element BlockVector{Int8}:\n 1\n ─\n 2\n 3\n\nSee also undef_blocks, UndefBlocksInitializer\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BlockArrays.BlockArray-Union{Tuple{N}, Tuple{T}, Tuple{UndefInitializer, Vararg{AbstractVector{<:Integer}, N}}} where {T, N}","page":"Public Documentation","title":"BlockArrays.BlockArray","text":"BlockArray{T}(::UndefInitializer, block_sizes::Vararg{AbstractVector{<:Integer}, N}) where {T, N}\n\nConstruct a N-dim BlockArray with blocks of type Array{T,N}, with sizes defined by block_sizes. The blocks are allocated using similar, and the elements in each block are therefore unitialized.\n\nExamples\n\njulia> B = BlockArray{Int8}(undef, [1,2]);\n\njulia> B[Block(1)] .= 2;\n\njulia> B[Block(2)] .= 3;\n\njulia> B\n2-blocked 3-element BlockVector{Int8}:\n 2\n ─\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BlockArrays.undef_blocks","page":"Public Documentation","title":"BlockArrays.undef_blocks","text":"undef_blocks\n\nAlias for UndefBlocksInitializer(), which constructs an instance of the singleton type UndefBlocksInitializer, used in block array initialization to indicate the array-constructor-caller would like an uninitialized block array.\n\nExamples\n\njulia> BlockArray(undef_blocks, Matrix{Float32}, [1,2], [3,2])\n2×2-blocked 3×5 BlockMatrix{Float32}:\n #undef  #undef  #undef  │  #undef  #undef\n ────────────────────────┼────────────────\n #undef  #undef  #undef  │  #undef  #undef\n #undef  #undef  #undef  │  #undef  #undef\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#BlockArrays.UndefBlocksInitializer","page":"Public Documentation","title":"BlockArrays.UndefBlocksInitializer","text":"UndefBlocksInitializer\n\nSingleton type used in block array initialization, indicating the array-constructor-caller would like an uninitialized block array. See also undef_blocks, an alias for UndefBlocksInitializer().\n\nExamples\n\njulia> BlockArray(undef_blocks, Matrix{Float32}, [1,2], [3,2])\n2×2-blocked 3×5 BlockMatrix{Float32}:\n #undef  #undef  #undef  │  #undef  #undef\n ────────────────────────┼────────────────\n #undef  #undef  #undef  │  #undef  #undef\n #undef  #undef  #undef  │  #undef  #undef\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.mortar","page":"Public Documentation","title":"BlockArrays.mortar","text":"mortar(blocks::AbstractArray)\nmortar(blocks::AbstractArray{R, N}, sizes_1, sizes_2, ..., sizes_N)\nmortar(blocks::AbstractArray{R, N}, block_sizes::Tuple{Vararg{AbstractUnitRange{<:Integer},N}})\n\nConstruct a BlockArray from blocks.  block_sizes is computed from blocks if it is not given.\n\nThis is an \"inverse\" of blocks.\n\nExamples\n\njulia> arrays = permutedims(reshape([\n                  fill(1.0, 1, 3), fill(2.0, 1, 2),\n                  fill(3.0, 2, 3), fill(4.0, 2, 2),\n              ], (2, 2)))\n2×2 Matrix{Matrix{Float64}}:\n [1.0 1.0 1.0]               [2.0 2.0]\n [3.0 3.0 3.0; 3.0 3.0 3.0]  [4.0 4.0; 4.0 4.0]\n\njulia> M = mortar(arrays)\n2×2-blocked 3×5 BlockMatrix{Float64}:\n 1.0  1.0  1.0  │  2.0  2.0\n ───────────────┼──────────\n 3.0  3.0  3.0  │  4.0  4.0\n 3.0  3.0  3.0  │  4.0  4.0\n\njulia> M == mortar(\n                  (fill(1.0, 1, 3), fill(2.0, 1, 2)),\n                  (fill(3.0, 2, 3), fill(4.0, 2, 2)),\n              )\ntrue\n\n\n\n\n\nmortar((block_11, ..., block_1m), ... (block_n1, ..., block_nm))\n\nConstruct a BlockMatrix with n * m  blocks.  Each block_ij must be an AbstractMatrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockappend!","page":"Public Documentation","title":"BlockArrays.blockappend!","text":"blockappend!(dest::BlockVector, sources...) -> dest\n\nAppend blocks from sources to dest.  The number of blocks in dest are increased by sum(blocklength, sources).\n\nThis function avoids copying the elements of the blocks in sources when these blocks are compatible with dest.  Importantly, this means that mutating sources afterwards alters the items in dest and it may even break the invariance of dest if the length of sources are changed.\n\nThe blocks in dest must not alias with sources or components of them. For example, the result of blockappend!(x, x) is undefined.\n\nExamples\n\njulia> using BlockArrays\n\njulia> blockappend!(mortar([[1], [2, 3]]), mortar([[4, 5]]))\n3-blocked 5-element BlockVector{Int64}:\n 1\n ─\n 2\n 3\n ─\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockpush!","page":"Public Documentation","title":"BlockArrays.blockpush!","text":"blockpush!(dest::BlockVector, blocks...) -> dest\n\nPush blocks to the end of dest.\n\nThis function avoids copying the elements of the blocks when these blocks are compatible with dest.  Importantly, this means that mutating blocks afterwards alters the items in dest and it may even break the invariance of dest if the length of blocks are changed.\n\nExamples\n\njulia> using BlockArrays\n\njulia> blockpush!(mortar([[1], [2, 3]]), [4, 5], [6])\n4-blocked 6-element BlockVector{Int64}:\n 1\n ─\n 2\n 3\n ─\n 4\n 5\n ─\n 6\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockpushfirst!","page":"Public Documentation","title":"BlockArrays.blockpushfirst!","text":"blockpushfirst!(dest::BlockVector, blocks...) -> dest\n\nPush blocks to the beginning of dest.  See also blockpush!.\n\nThis function avoids copying the elements of the blocks when these blocks are compatible with dest.  Importantly, this means that mutating blocks afterwards alters the items in dest and it may even break the invariance of dest if the length of blocks are changed.\n\nExamples\n\njulia> using BlockArrays\n\njulia> blockpushfirst!(mortar([[1], [2, 3]]), [4, 5], [6])\n4-blocked 6-element BlockVector{Int64}:\n 4\n 5\n ─\n 6\n ─\n 1\n ─\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockpop!","page":"Public Documentation","title":"BlockArrays.blockpop!","text":"blockpop!(A::BlockVector) -> block\n\nPop a block from the end of dest.\n\nExamples\n\njulia> using BlockArrays\n\njulia> A = mortar([[1], [2, 3]]);\n\njulia> blockpop!(A)\n2-element Vector{Int64}:\n 2\n 3\n\njulia> A\n1-blocked 1-element BlockVector{Int64}:\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.blockpopfirst!","page":"Public Documentation","title":"BlockArrays.blockpopfirst!","text":"blockpopfirst!(dest::BlockVector) -> block\n\nPop a block from the beginning of dest.\n\nExamples\n\njulia> using BlockArrays\n\njulia> A = mortar([[1], [2, 3]]);\n\njulia> blockpopfirst!(A)\n1-element Vector{Int64}:\n 1\n\njulia> A\n1-blocked 2-element BlockVector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.append!","page":"Public Documentation","title":"Base.append!","text":"append!(dest::BlockVector, sources...)\n\nAppend items from sources to the last block of dest.\n\nThe blocks in dest must not alias with sources or components of them. For example, the result of append!(x, x) is undefined.\n\nExamples\n\njulia> using BlockArrays\n\njulia> append!(mortar([[1], [2, 3]]), mortar([[4], [5]]))\n2-blocked 5-element BlockVector{Int64}:\n 1\n ─\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.push!","page":"Public Documentation","title":"Base.push!","text":"push!(dest::BlockVector, items...)\n\nPush items to the end of the last block.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.pushfirst!","page":"Public Documentation","title":"Base.pushfirst!","text":"pushfirst!(A::BlockVector, items...)\n\nPush items to the beginning of the first block.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.pop!","page":"Public Documentation","title":"Base.pop!","text":"pop!(A::BlockVector)\n\nPop the last element from the last non-empty block.  Remove all empty blocks at the end.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.popfirst!","page":"Public Documentation","title":"Base.popfirst!","text":"popfirst!(A::BlockVector)\n\nPop the first element from the first non-empty block.  Remove all empty blocks at the beginning.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockedArray","page":"Public Documentation","title":"BlockedArray","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"BlockedArray\nBlockedVector\nBlockedMatrix\nBase.resize!","category":"page"},{"location":"lib/public/#BlockArrays.BlockedArray","page":"Public Documentation","title":"BlockArrays.BlockedArray","text":"BlockedArray{T, N, R} <: AbstractBlockArray{T, N}\n\nA BlockedArray is similar to a BlockArray except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand parent on a BlockedArray is instead instant since it just returns the wrapped array.\n\nWhen iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a BlockedArray to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using parent.\n\nExamples\n\njulia> A = zeros(Int, 2, 3);\n\njulia> B = BlockedArray(A, [1,1], [2,1])\n2×2-blocked 2×3 BlockedMatrix{Int64}:\n 0  0  │  0\n ──────┼───\n 0  0  │  0\n\njulia> parent(B) === A\ntrue\n\njulia> B[Block(1,1)] .= 4\n1×2 view(::Matrix{Int64}, 1:1, 1:2) with eltype Int64:\n 4  4\n\njulia> A\n2×3 Matrix{Int64}:\n 4  4  0\n 0  0  0\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.BlockedVector","page":"Public Documentation","title":"BlockArrays.BlockedVector","text":"BlockedVector{T}\n\nAlias for BlockedArray{T, 1}\n\njulia> A = [1:6;]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> BlockedVector(A, [3,2,1])\n3-blocked 6-element BlockedVector{Int64}:\n 1\n 2\n 3\n ─\n 4\n 5\n ─\n 6\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.BlockedMatrix","page":"Public Documentation","title":"BlockArrays.BlockedMatrix","text":"BlockedMatrix{T}\n\nAlias for BlockedArray{T, 2}\n\njulia> A = reshape([1:6;], 2, 3)\n2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia> BlockedMatrix(A, [1,1], [1,2])\n2×2-blocked 2×3 BlockedMatrix{Int64}:\n 1  │  3  5\n ───┼──────\n 2  │  4  6\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Base.resize!","page":"Public Documentation","title":"Base.resize!","text":"resize!(a::BlockVector, N::Block) -> BlockedVector\n\nResize a to contain the first N blocks, returning a new BlockVector sharing memory with a. If N is smaller than the current collection block length, the first N blocks will be retained. N is not allowed to be larger.\n\n\n\n\n\nresize!(a::BlockedVector, N::Block) -> BlockedVector\n\nResize a to contain the first N blocks, returning a new BlockedVector sharing memory with a. If N is smaller than the current collection block length, the first N blocks will be retained. N is not allowed to be larger.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Kronecker-products","page":"Public Documentation","title":"Kronecker products","text":"","category":"section"},{"location":"lib/public/","page":"Public Documentation","title":"Public Documentation","text":"blockkron\nBlockKron\nblockvec\nkhatri_rao","category":"page"},{"location":"lib/public/#BlockArrays.blockkron","page":"Public Documentation","title":"BlockArrays.blockkron","text":"blockkron(A...)\n\nReturn a blocked version of kron(A...) with the natural block-structure imposed.\n\nExamples\n\njulia> A = reshape(1:9, 3, 3)\n3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> BlockArrays.blockkron(A, A)\n3×3-blocked 9×9 BlockMatrix{Int64}:\n 1   4   7  │   4  16  28  │   7  28  49\n 2   5   8  │   8  20  32  │  14  35  56\n 3   6   9  │  12  24  36  │  21  42  63\n ───────────┼──────────────┼────────────\n 2   8  14  │   5  20  35  │   8  32  56\n 4  10  16  │  10  25  40  │  16  40  64\n 6  12  18  │  15  30  45  │  24  48  72\n ───────────┼──────────────┼────────────\n 3  12  21  │   6  24  42  │   9  36  63\n 6  15  24  │  12  30  48  │  18  45  72\n 9  18  27  │  18  36  54  │  27  54  81\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.BlockKron","page":"Public Documentation","title":"BlockArrays.BlockKron","text":"BlockKron(A...)\n\nCreate a lazy representation of kron(A...) with the natural block-structure imposed. This is a component in blockkron(A...).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#BlockArrays.blockvec","page":"Public Documentation","title":"BlockArrays.blockvec","text":"blockvec(A::AbstractMatrix)\n\ncreates a blocked version of vec(A), with the block structure used to represent the columns.\n\nExamples\n\njulia> A = reshape(1:9, 3, 3)\n3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> BlockArrays.blockvec(A)\n3-blocked 9-element BlockedVector{Int64, UnitRange{Int64}, Tuple{BlockedOneTo{Int64, StepRangeLen{Int64, Int64, Int64, Int64}}}}:\n 1\n 2\n 3\n ─\n 4\n 5\n 6\n ─\n 7\n 8\n 9\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#BlockArrays.khatri_rao","page":"Public Documentation","title":"BlockArrays.khatri_rao","text":"khatri_rao(A, B)\n\nReferences\n\nLiu, Shuangzhe, and Gõtz Trenkler (2008) Hadamard, Khatri-Rao, Kronecker and Other Matrix Products. International J. Information and Systems Sciences 4, 160–177.\nKhatri, C. G., and Rao, C. Radhakrishna (1968) Solutions to Some Functional Equations and Their Applications to Characterization of Probability Distributions. Sankhya: Indian J. Statistics, Series A 30, 167–180.\n\n\n\n\n\n","category":"function"},{"location":"#BlockArrays.jl","page":"Home","title":"BlockArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Block arrays in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A block array is a partition of an array into multiple blocks or subarrays, see wikipedia for a more extensive description. This package has two purposes. Firstly, it defines an interface for an AbstractBlockArray block arrays that can be shared among types representing different types of block arrays. The advantage to this is that it provides a consistent API for block arrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Secondly, it also implements two concrete types of block arrays that follow the AbstractBlockArray interface.  The type BlockArray stores each single block contiguously, by wrapping an AbstractArray{<:AbstractArray{T,N},N} to concatenate all blocks – the complete array is thus not stored contiguously.  Conversely, a BlockedArray stores the full matrix contiguously (by wrapping only one AbstractArray{T, N}) and only superimposes a block structure.  This means that BlockArray supports fast non copying extraction and insertion of blocks, while BlockedArray supports fast access to the full matrix to use in, for example, a linear solver.","category":"page"},{"location":"#Terminology","page":"Home","title":"Terminology","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We talk about an “a×b-blocked m×n block array”, if we have m times n values arranged in a times b blocks, like in the following example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"2×3-blocked 4×4 BlockMatrix{Float64}:\n 0.56609   │  0.95429   │  0.0688403  0.980771 \n 0.203829  │  0.138667  │  0.0200418  0.0515364\n ──────────┼────────────┼──────────────────────\n 0.963832  │  0.391176  │  0.925799   0.148993 \n 0.18693   │  0.838529  │  0.801236   0.793251","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dimension of arrays works the same as with standard Julia arrays; for example the following is a 2 times 2 block vector:","category":"page"},{"location":"","page":"Home","title":"Home","text":"2-blocked 4-element BlockVector{Float64}:\n 0.35609231970760424\n 0.7732179994849591 \n ───────────────────\n 0.8455294223894625 \n 0.04250653797187476","category":"page"},{"location":"","page":"Home","title":"Home","text":"A block array layout is specified its block sizes – a tuple of AbstractArray{Int}.  The length of the tuple is equal to the dimension, the length of each block size array is the number of blocks in the corresponding dimension, and the sum of each block size is the scalar size in that dimension.  For example, BlockArray{Int}(undef, [2,2,2], [2,2,2], [2,2,2]) will produce a blocked cube (an AbstractArray{Int, 3}, i.e., 3 dimensions), consisting of 27 2×2×2 blocks (3 in each dimension) and 216 values (6 in each dimension).","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/abstractblockarrayinterface.md\", \"man/blockarrays.md\", \"man/blockedarrays.md\"]\nDepth = 2","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]\nDepth = 2","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]","category":"page"}]
}
