<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PseudoBlockArrays · BlockArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BlockArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="abstractblockarrayinterface.html">The <code>AbstractBlockSizes</code> interface</a></li><li><a class="toctext" href="blockarrays.html">BlockArrays</a></li><li class="current"><a class="toctext" href="pseudoblockarrays.html">PseudoBlockArrays</a><ul class="internal"><li><a class="toctext" href="#Creating-PseudoBlockArrays-1">Creating PseudoBlockArrays</a></li><li><a class="toctext" href="#Creating-initialized-BlockArrays-1">Creating initialized <code>BlockArrays</code></a></li><li><a class="toctext" href="#Setting-and-getting-blocks-and-values-1">Setting and getting blocks and values</a></li><li><a class="toctext" href="#Views-of-blocks-1">Views of blocks</a></li></ul></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="pseudoblockarrays.html">PseudoBlockArrays</a></li></ul><a class="edit-page" href="https://github.com/JuliaArrays/BlockArrays.jl/blob/master/docs/src/man/pseudoblockarrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PseudoBlockArrays</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="PseudoBlockArrays-1" href="#PseudoBlockArrays-1">PseudoBlockArrays</a></h1><p>A <code>PseudoBlockArray</code> is similar to a <a href="../lib/public.html#BlockArrays.BlockArray"><code>BlockArray</code></a> except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand, converting a `<code>PseudoBlockArray</code> to the &quot;full&quot; underlying array is instead instant since it can just return the wrapped array.</p><p>When iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a <code>PseudoBlockArray</code> to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using <code>full</code>.</p><h2><a class="nav-anchor" id="Creating-PseudoBlockArrays-1" href="#Creating-PseudoBlockArrays-1">Creating PseudoBlockArrays</a></h2><p>Creating a <code>PseudoBlockArray</code> works in the same way as a <code>BlockArray</code>.</p><pre><code class="language-julia-repl">julia&gt; pseudo = PseudoBlockArray(rand(3,3), [1,2], [2,1])
2×2-blocked 3×3 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:
 0.590845  0.460085  │  0.200586
 ────────────────────┼──────────
 0.766797  0.794026  │  0.298614
 0.566237  0.854147  │  0.246837</code></pre><p>This &quot;takes ownership&quot; of the passed in array so no copy of the array is made.</p><h2><a class="nav-anchor" id="Creating-initialized-BlockArrays-1" href="#Creating-initialized-BlockArrays-1">Creating initialized <code>BlockArrays</code></a></h2><p>A block array can be created with uninitialized entries using the <code>BlockArray{T}(undef, block_sizes...)</code> function. The block_sizes are each an <code>AbstractVector{Int}</code> which determines the size of the blocks in that dimension. We here create a <code>[1,2]×[3,2]</code> block matrix of <code>Float32</code>s:</p><pre><code class="language-julia">julia&gt; PseudoBlockArray{Float32}(undef, [1,2], [3,2])
2×2-blocked 3×5 BlockArrays.BlockArray{Float32,2,Array{Float32,2}}:
 9.39116f-26  1.4013f-45   3.34245f-21  │  9.39064f-26  1.4013f-45
 ───────────────────────────────────────┼──────────────────────────
 3.28434f-21  9.37645f-26  3.28436f-21  │  8.05301f-24  9.39077f-26
 1.4013f-45   1.4013f-45   1.4013f-45   │  1.4013f-45   1.4013f-45</code></pre><p>We can also any other user defined array type that supports <code>similar</code>.</p><h2><a class="nav-anchor" id="Setting-and-getting-blocks-and-values-1" href="#Setting-and-getting-blocks-and-values-1">Setting and getting blocks and values</a></h2><p>Setting and getting blocks uses the same API as <code>BlockArrays</code>. The difference here is that setting a block will update the block in place and getting a block will extract a copy of the block and return it. For <code>PseudoBlockArrays</code> there is a mutating block getter called <code>getblock!</code> which updates a passed in array to avoid a copy:</p><pre><code class="language-julia-repl">julia&gt; A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; getblock!(A, pseudo, 2, 1);

julia&gt; A
2×2 Array{Float64,2}:
 0.766797  0.794026
 0.566237  0.854147</code></pre><p>It is sometimes convenient to access an index in a certain block. We could of course write this as <code>A[Block(I,J)][i,j]</code> but the problem is that <code>A[Block(I,J)]</code> allocates its output so this type of indexing will be inefficient. Instead, it is possible to use the <code>A[BlockIndex((I,J), (i,j))]</code> indexing. Using the same block matrix <code>A</code> as above:</p><pre><code class="language-julia-repl">julia&gt; pseudo[BlockIndex((2,1), (2,2))]
0.8541465903790502</code></pre><p>The underlying array is accessed with <code>Array</code> just like for <code>BlockArray</code>.</p><h2><a class="nav-anchor" id="Views-of-blocks-1" href="#Views-of-blocks-1">Views of blocks</a></h2><p>We can also view and modify views of blocks of <code>PseudoBlockArray</code> using the <code>view</code> syntax:</p><pre><code class="language-julia-repl">julia&gt; A = PseudoBlockArray(ones(6), 1:3);

julia&gt; view(A, Block(2))
2-element SubArray{Float64,1,BlockArrays.PseudoBlockArray{Float64,1,Array{Float64,1}},Tuple{BlockArrays.BlockSlice},false}:
 1.0
 1.0

julia&gt; view(A, Block(2)) .= [3,4]; A[Block(2)]
2-element Array{Float64,1}:
 3.0
 4.0</code></pre><p>Note that, in memory, each block is in a BLAS-Level 3 compatible format, so that, in the future, algebra with blocks will be highly efficient.</p><footer><hr/><a class="previous" href="blockarrays.html"><span class="direction">Previous</span><span class="title">BlockArrays</span></a><a class="next" href="../lib/public.html"><span class="direction">Next</span><span class="title">Public Documentation</span></a></footer></article></body></html>
